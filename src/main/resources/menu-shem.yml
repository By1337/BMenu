#
# Указатели
# ДЛЯ ПОНИМАНИЯ ПРОИСХОДЯЩЕГО НЕОБХОДИМО ЗНАТЬ ЧТО ТАКОЕ УКАЗАТЕЛИ В YAML
# Если вы не знаете что такое указатели то погуглите про них
#
# Помимо обычного указателя << было добавлено два новых
# <<+ - объединяющий указатель и <<* заменяющий указатель
# Пример использования объединяющего указателя
# defaults:
#  item: &item
#    args:
#      PARAM_1: param1
#      PARAM_2: param2
#  result:
#    args:
#      PARAM_3: param3
#      PARAM_4: param4
#    <<+: *item
# В результате будет
# result:
#  args:
#    PARAM_3: param3
#    PARAM_4: param4
#    PARAM_1: param1
#    PARAM_2: param2
# Если бы мы использовали простой указатель то он бы ничего не сделал так как args уже определён в result
#
# <<* - заменяющий указатель работает аналогично указателю <<+ только он заменят значения на значения из указателя если они уже объявлены
# Пример использования заменяющего указателя
# defaults:
#  item: &item
#    args:
#      PARAM_1: param1
#      PARAM_2: param2
#  result:
#    args:
#      PARAM_1: custom_value
#    <<+: *item
# В результате будет
# result:
#  args:
#    PARAM_1: param1
#    PARAM_2: param2
#
# здесь PARAM_1 был заменён на значение из указателя


## Терминология
# Иерархия открытых меню
# При открытии одного меню из другого создаётся цепочка, называемая иерархией меню
# Иерархия существует до тех пор, пока последнее открытое меню остаётся открытым
# Меню не знает, какое меню находится выше по иерархии, но знает, какое было до него
# Пример:
# Есть меню A, B, C
# Пользователь открывает меню A
# Иерархия: A
# Из меню A пользователь открывает меню B
# Иерархия: A -> B
# Затем из меню B пользователь открывает меню C
# Иерархия: A -> B -> C
# В этом примере образовалась цепочка из трёх меню
# Меню B знает, что до него было меню A, но не знает, что после него меню C
# Если пользователь воспользуется командой [BACK], он вернётся в предыдущее меню, а текущее меню закроется
# Иерархия: A -> B


# Должны импортироваться все настройки указанных файлов, включая их extends
# Циклические зависимости не должны влиять на работу системы и считаются допустимыми
## Терминология
# указанные здесь меню это родительские меню
# текущее меню это наследник
extends:
  - ./file.yml # путь относительно текущей папки
  - ../file.yml # путь относительно папки на уровень выше
  - /file.yml  # путь относительно корневой папки с меню


# Объединяет файлы в один.
# Используйте это для импорта указателей.
# Объединение файлов происходит до чтения yaml, если вы объедините две менюшки то меню точно поломается,
# Для объединения менюшек используйте extends.
# Повторю этот параметр просто склеивает вда файла в один.
# УКАЗЫВАТЕ ФАЙЛЫ ТОЛЬКО В ТАКОМ ФОРМАТЕ include: []
# Также запрещено добавлять комментарии в блок include
# Всегда оборачивайте значения в кавычки.
include: [
  "./file.yml",
  "../file.yml",
  "/file.yml",
]

# здесь вы можете объявлять наборы команд
# после вы можете их выполнять используя команду
# [RUN] <имя набора>
# Или выполнять рандомно
# [RUN_RAND]
commands-list:
  example-1:
    weight: 1.0 # Необязательный параметр. Это вес этого набора он будет использоваться если вызвать случайные команды через [RUN_RAND]
    commands:
      - '[MESSAGE] &7Это команда из example-1'
  example-2:
    weight: 1.0
    commands:
      - '[MESSAGE] &7Это команда из example-1'

# Меню ивенты
menu-events:
  on_open: # когда меню открывается
    requirements: # здесь можно указать условия
      - check: 'str == str'
        deny_commands: [ ] # во всех проверках тоже можно указывать команды
    deny_commands: [ ]
    commands:
      - '[MESSAGE] Меню открыто!'
  on_reopen: # когда меню пере-открывается, когда используется команда [BACK]
    deny_commands: [ ]
    commands:
      - '[MESSAGE] Меню открыто заново!'
  on_close: # когда меню закрывается
    deny_commands: [ ]
    commands:
      - '[MESSAGE] Меню закрыто!'


# Если namespace не указан, должно использоваться имя плагина, который загрузил это меню
# При использовании команд [OPEN] или аналогичных без указания конкретного namespace,
# menu loader должен сначала искать меню в своём окружении
# В случае неоднозначных вызовов должна быть выведена ошибка
# Один menu loader не может получить доступ к другому, если это явно не указано в реализации
# id может быть не указан, в этом случае menu loader не сможет найти это меню. Это может быть полезно при использовании зависимостей в extends
## Терминология
# меню без id называется безымянным
id: <namespace>:<id>
# Если namespace не указан, должно использоваться имя плагина, который загрузил это меню
# Все конфликты и неоднозначные указания реализаций должны быть выявлены на этапе загрузки menu loader
# Один menu loader не может получить доступ к реализациям другого, если это явно не указано в реализации
# Исключение составляют реализации по умолчанию, предоставляемые API
# provider может быть не указан, тогда это меню нельзя будет открыть
provider: <namespace>:<id>
type: CHEST
size: 27
title: '&7Menu title'

# Указывает из каких меню может быть открыто это меню
# Этот параметр наследуется из родительских меню
# Все наследники указанного здесь меню также имеют право открывать это меню
only-open-from:
  - <namespace>:<id>

# глобальные переменные меню
# могут быть использованы в любом месте в этом меню
# Все родительские меню также могут использовать эти переменные.
# Все наследники этого меню могут использовать эти переменные
# Этот параметр наследуется
# синтаксис использования ${PARAM_1}
# могут быть изменены командой [SET_PARAM]
# Эти параметры не статичны и уникальны для каждого открытого меню, а также они существуют пока это меню открыто или находится в иерархии открытых меню
args:
  PARAM_1: 'value'
  PARAM_2: 'value'
  PARAM_3: 'value'

# блок с дефолтными значениями
# он может назваться как угодно
# этот блок не наследуется
# здесь он приведён в качестве примера как можно использовать указатели и переменные которые можно объявить в предмете
defaults:
  on_left_click_logic: &on_left_click_logic
    requirements:
      - check: '%vault_eco_balance_fixed% >= ${PRICE}'
    deny_commands:
      - '[MESSAGE] &cУ Вас не достаточно баланса!'
    commands:
      - '[CONSOLE] eco take %player_name% ${PRICE}'
      - '[CONSOLE] give %player_name% ${MATERIAL} ${AMOUNT}'
      - '[MESSAGE] &aВы успешно купили ${NAME} в количестве ${AMOUNT}'

items:
  # наследники могут использовать объявленные здесь предметы в анимациях,
  # Например если в этом меню и в родительском меню будут предметы с именем item-1 то это меню будет использовать свой item-1, а родительское свой item-1.
  itemID:
    material: <material> # или basehead-<value> или плейсхолдер
    display_name: "Имя предмета"
    amount: 1 # или плейсхолдер
    lore: [ ] # описание
    item_flags: [ ] # все флаги https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemFlag.html
    all_flags: true # включает существующие флаги
    potion_effects:
      - "speed;20;0" # <PotionEffectType>;<duration>;<amplifier>
    color: '#aabbcc' # для зелий и кожаной брони
    enchantments:
      - protection;1 # enchantmentid;level
    unbreakable: true
    model_data: 0
    damage: 10
    priority: 0
    ticking: false # Будет ли предмет обновляться сам по себе
    tick-speed: 20 # каждую секунду предмет будет обновляться если ticking = true
    # если этот предмет не имеет никаких плейсхолдеров и этот предмет всегда одинаковый,
    # то вы можете указать этот параметр как true и тогда плагин перестанет каждый раз заново создать этот предмет.
    # На команды и условия этот параметр не распространяется только на визуальную часть предмета
    static: true
    # слоты могут быть не указаны
    # если указать слоты то этот предмет установится при инициализации меню
    slot: 10
    slots:
      - '10'
      - '11'
      - '12-20'
    # аналог переменных меню, но только эти переменные видны только этому предмету
    # Также эти переменные константные.
    # Использовать аналогично ${PARAM_1}
    args:
      PARAM_1: 'value'
      PARAM_2: 'value'
      PARAM_3: 'value'
    view_requirement: # алиас view_req
      # если в type перед проверкой поставить ! то проверка будет работать на оборот
      # например type: '!has permission' такая проверка сработает если игрок не имеет пермишена
      requirements: # алиас req
        - check: '100 + 100 * 100 == 15'
          commands: [ ]
          deny_commands: [ ]
        - check: '100.5 + 100.5 == 201'
        - check: 'has super.permission' # если у игрока есть пермишен
        - check: '!has super.permission' # если у игрока нет пермишена
        - check: 'string has str' # строка содержит
        - check: 'string !has str' # строка не содержит
        - check: 'string HAS str' # строка содержит без учёта регистра
        - check: 'string !HAS str' # строка не содержит без учёта регистра
        - check: 'string == string' # строка равна
        - check: 'string != string' # строка не равна
        - check: 'nearby world 10 10 10 100' # условие что игрок находится в радиусе 100 блоков от координат 10 10 10 в мире world
          commands:
            - '[MESSAGE] string != string'
            - '[BREAK]' # Эта команда доступна только в условиях, она прерывает проверку следующих условий и выполнение следующих команд
            - '[CLOSE]' # Так как выше команда [BREAK] команда [CLOSE] не будет выполнена
####### НИЖЕ СТАРЫЙ ФОРМАТ ЕГО ТАКЖЕ МОЖНО ИСПОЛЬЗОВАТЬ #######
#      requirements: # алиас req
#        check: # если условие окажется ложным, то проверка остальных условий прервётся
#          type: math
#          expression: '100 + 100 == 10 * (5 * 4)'
#          deny_commands: [ ] # во всех проверках тоже можно указывать команды
#          commands: [ ]
#        check-1:
#          type: string equals
#          input: 'str'
#          output: 'str'
#          commands:
#        check-2:
#          type: string equals ignorecase
#          input: 'str'
#          output: 'STR'
#        check-3:
#          type: string contains
#          input: 'str_str_str'
#          output: 'str'
#        check-4:
#          type: regex matches
#          regex: '^(str)\d+'
#          input: 'str88ing'
#        check-5:
#          type: has permission
#          permission: 'admin.use'
      # Здесь можно выполнить команды в зависимости от результатов условий
      deny_commands: [ ] # если хотя бы одно из условий окажется ложным
    on_left_click: # обработка клика
      requirements: # здесь можно указать условия
        - check: 'str == str'
      # Здесь можно указываются команды в зависимости от результатов проверки
      deny_commands: [ ]
      commands: [ ]

  example:
    args:
      MATERIAL: STONE
      PRICE: 10
      AMOUNT: 64
      NAME: 'камень'
    material: ${MATERIAL}
    amount: ${AMOUNT}
    display_name: '&7${NAME} x${AMOUNT}'
    lore:
      - '&r '
      - '&r &7Нажмите лкм'
      - '&r &7чтобы купить ${NAME} в количестве ${AMOUNT}'
      - '&r '
    on_left_click:
      <<: *on_left_click_logic


# Все виды кликов
# on_left_click
# on_right_click
# on_shift_left_click
# on_shift_right_click
# on_middle_click
# on_drop_click
# on_click - любой не назначенный клик
# on_number_key_0_click
# on_number_key_1_click
# on_number_key_2_click
# on_number_key_3_click
# on_number_key_4_click
# on_number_key_5_click
# on_number_key_6_click
# on_number_key_7_click
# on_number_key_8_click
# on_swap_offhand_click
# on_control_drop_click


# Вы можете использовать предметы, добавленные в родительские меню.
# Однако взаимодействовать с предметами, уже находящимися в меню, нельзя.
# Меню состоит из двух слоёв:
# - **Первый слой**: включает предметы, добавленные при открытии меню (те, что указаны в параметре `items` и привязаны к определённым слотам), а также предметы, установленные плагином.
# - **Второй слой**: это слой анимации, где находятся предметы, добавленные анимацией.
#
# Анимация может взаимодействовать только с элементами своего слоя, однако она может перекрывать предметы первого слоя.
animation:
  - tick: 0 # на каком тике анимации следует применить этот фрейм, если не указать, то будет на один больше, чем предыдущий
    opcodes:
      - fill: itemID # устанавливает предмет во все слоты меню
      - set: itemID 13 # устанавливает предмет в указанный слот
      - set: itemID 10-20 # устанавливает предмет в указанные слоты
      - set: AIR 10-20 # удаляет предметы в указанных слотах
      - remove: 10-20 # аналогично set: AIR 10-20
      - remove-if-not-empty: 10-20 # удаляет предмет из слоя анимации если на основном слое есть предмет
      - move: 13 14 # перемещает предмет из слота 13 в слот 14, в слот 13 устанавливается AIR
      - move: 10-15 20-25 # перемещает предметы из слотов 10-15 в слоты 20-25
      - move: 13++ # перемещает предмет из слота 13 в слот 14
      - move: 13++ # перемещает предмет из слота 13 в слот 14
      - move: 13,17 15,20 # перемещает предметы из слотов 13 и 17 в слоты 15 и 20
      - swap: 10 11 # меняет местами предметы в слотах 10 и 11
      - swap: 10++ # меняет местами предметы в слотах 10 и 11
      - swap: 10-- # меняет местами предметы в слотах 10 и 9
      - swap: 10-15 20-25 # меняет местами предметы в слотах 10-15 и 20-25
      - copy: 10 11 # копирует предмет из слота 10 в слот 11
      - copy: 10++ # копирует предмет из слота 10 в слот 11
      - copy: 10-- # копирует предмет из слота 10 в слот 9
      - copy: 10-15 20-25 # копирует предметы из слотов 10-15 в слоты 20-25
      - goto: 13 # переходит к указанному тику, позволяет зациклить анимацию
      - sound: ENTITY_EXPERIENCE_ORB_PICKUP 1.0 1.0 # воспроизводит звук для игрока
      - commands: # выполняет команды
          - '[MESSAGE] msg'
      - title: title # устанавливает title меню

animations:
  default:
    - tick: 0
      opcodes: [ ]
  other:
    - tick: 0
      opcodes: [ ]

# Все команды
# [CONSOLE] <cmd>
# [PLAYER] <cmd>
# [CHAT] <msg> - отправит сообщение от имени игрока, также можно выполнить команду
# [SOUND] <sound> <?volume> <?pitch>
# [CLOSE]
# здесь команды открытия меню
# В commands вы можете передать список команд которые необходимо выполнить в открывающейся менюшке
# Синтаксис [OPEN] menu ["[MESSAGE] сообщение из открытого меню", "[что-то] некст команда"]
# [BACK_OR_CLOSE] <?commands>
# [BACK_TO_OR_CLOSE] <id> <?commands>
# [BACK] <?commands>
# [OPEN] <id> <?commands>
# [BACK_OR_OPEN] <id> <?commands>
#
# [REOPEN] - полностью заново открывает текущее меню
# [REFRESH]
# [MESSAGE] <msg>
# [SET_PARAM] <param> <value>
# [IMPORT_PARAMS] <item>
# Команды ниже выполняют команды из блока commands-list
# [RUN] <имя набора>
# [RUN_RAND]
# [CONNECT] <server> - подключает игрока к серверу
# [SET_ANIMATION] <animation> - устанавливает анимацию из блока animations
#
# [GIVEMONEY] <count> - выдать деньги
# [TAKEMONEY] <count> - забрать деньги
# [DELAY] <delay> <cmd> - выполнить команду с задержкой например [DELAY] 20 [MESSAGE] &aЭто сообщение отправилось спустя 1 секунду!
#
# [TITLE_ALL] <"Title\nSubTitle"> <?fadeIn> <?stay> <?fadeOut>
# [TITLE] <"Title\nSubTitle"> <?fadeIn> <?stay> <?fadeOut>
# [ACTION_BAR_ALL] <msg>
# [ACTION_BAR] <msg>
# [BROADCAST] <msg>
## Терминология
# Иерархия открытых меню
# При открытии одного меню из другого создаётся цепочка, называемая иерархией меню
# Иерархия существует до тех пор, пока последнее открытое меню остаётся открытым
# Меню не знает, какое меню находится выше по иерархии, но знает, какое было до него
# Пример:
# Есть меню A, B, C
# Пользователь открывает меню A
# Иерархия: A
# Из меню A пользователь открывает меню B
# Иерархия: A -> B
# Затем из меню B пользователь открывает меню C
# Иерархия: A -> B -> C
# В этом примере образовалась цепочка из трёх меню
# Меню B знает, что до него было меню A, но не знает, что после него меню C
# Если пользователь воспользуется командой [BACK], он вернётся в предыдущее меню, а текущее меню закроется
# Иерархия: A -> B


# Должны импортироваться все настройки указанных файлов, включая их extends
# Циклические зависимости не должны влиять на работу системы и считаются допустимыми
## Терминология
# указанные здесь меню это родительские меню
# текущее меню это наследник
extends:
  - ./file.yml # путь относительно текущей папки
  - ../file.yml # путь относительно папки на уровень выше
  - /file.yml  # путь относительно корневой папки с меню

# Если namespace не указан, должно использоваться имя плагина, который загрузил это меню
# При использовании команд [OPEN] или аналогичных без указания конкретного namespace,
# menu loader должен сначала искать меню в своём окружении
# В случае неоднозначных вызовов должна быть выведена ошибка
# Один menu loader не может получить доступ к другому, если это явно не указано в реализации
# id может быть не указан, в этом случае menu loader не сможет найти это меню. Это может быть полезно при использовании зависимостей в extends
## Терминология
# меню без id называется безымянным
id: <namespace>:<id>
# Если namespace не указан, должно использоваться имя плагина, который загрузил это меню
# Все конфликты и неоднозначные указания реализаций должны быть выявлены на этапе загрузки menu loader
# Один menu loader не может получить доступ к реализациям другого, если это явно не указано в реализации
# Исключение составляют реализации по умолчанию, предоставляемые API
# provider может быть не указан, тогда это меню нельзя будет открыть
provider: <namespace>:<id>
type: CHEST
size: 27
title: '&7Menu title'

# Указывает из каких меню может быть открыто это меню
# Этот параметр наследуется из родительских меню
# Все наследники указанного здесь меню также имеют право открывать это меню
only-open-from:
  - <namespace>:<id>

# глобальные переменные меню
# могут быть использованы в любом месте в этом меню
# Все родительские меню также могут использовать эти переменные.
# Все наследники этого меню могут использовать эти переменные
# Этот параметр наследуется
# синтаксис использования ${PARAM_1}
# могут быть изменены командой [SET_PARAM]
# Эти параметры не статичны и уникальны для каждого открытого меню, а также они существуют пока это меню открыто или находится в иерархии открытых меню
args:
  PARAM_1: 'value'
  PARAM_2: 'value'
  PARAM_3: 'value'

# блок с дефолтными значениями
# он может назваться как угодно
# этот блок не наследуется
# здесь он приведён в качестве примера как можно использовать указатели и переменные которые можно объявить в предмете
defaults:
  on_left_click_logic: &on_left_click_logic
    requirements:
      type: math
      expression: '%balance% >= ${PRICE}'
    deny_commands:
      - '[MESSAGE] &cУ Вас не достаточно баланса!'
    commands:
      - '[CONSOLE] eco take %player_name% ${PRICE}'
      - '[CONSOLE] give %player_name% ${MATERIAL} ${AMOUNT}'
      - '[MESSAGE] &aВы успешно купили ${NAME} в количестве ${AMOUNT}'

# Этот параметр наследуется
items:
  # здесь указывается id предмета
  # наследники могут использовать объявленные здесь предметы,
  # Например если в этом меню и в родительском меню будут предметы с именем item-1 то при обращении к предмету через короткое имя
  # это меню будет использовать свой item-1, а родительское свой item-1.
  # Все родительские меню также могут использовать эти предметы.
  itemID:
    material: <material> # или basehead-<value> или плейсхолдер
    display_name: "Имя предмета"
    amount: 1 # или плейсхолдер
    lore: [ ] # описание
    item_flags: [ ] # все флаги https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemFlag.html
    potion_effects:
      - "speed;20;0" # <PotionEffectType>;<duration>;<amplifier>
    color: '#aabbcc' # для зелий и кожиной брони
    enchantments:
      - protection;1 # enchantmentid;level
    unbreakable: true
    model_data: 0
    priority: 0
    # слоты могут быть не указаны
    # если указать слоты то этот предмет установится при инициализации меню
    slot: 10
    slots:
      - '10'
      - '11'
      - '12-20'
    # аналог переменных меню, но только эти переменные видны только этому предмету
    # Также эти переменные константные.
    # Использовать аналогично ${PARAM_1}
    args:
      PARAM_1: 'value'
      PARAM_2: 'value'
      PARAM_3: 'value'
    view_requirement: # алиас view_req
      # если в type перед проверкой поставить ! то проверка будет работать на оборот
      # например type: '!has permission' такая проверка сработает если игрок не имеет пермишена
      requirements: # алиас req
        check: # если условие окажется ложным, то проверка остальных условий прервётся
          type: math
          expression: '100 + 100 == 10 * (5 * 4)'
        check-1:
          type: string equals
          input: 'str'
          output: 'str'
        check-2:
          type: string equals ignorecase
          input: 'str'
          output: 'STR'
        check-3:
          type: string contains
          input: 'str_str_str'
          output: 'str'
        check-4:
          type: regex matches
          regex: '^(str)\d+'
          input: 'str88ing'
        check-5:
          type: has permission
          permission: 'admin.use'
      # Здесь можно выполнить команды в зависимости от результатов условий
      deny_commands: [] # если хотя бы одно из условий окажется ложным
    on_left_click: # обработка клика
      requirements: # здесь можно указать условия
        check-1:
          type: string equals
          input: 'str'
          output: 'str'
      # Здесь можно указываются команды в зависимости от результатов проверки
      deny_commands: []
      commands: []

  example:
    args:
      MATERIAL: STONE
      PRICE: 10
      AMOUNT: 64
      NAME: 'камень'
    material: ${MATERIAL}
    amount: ${AMOUNT}
    display_name: '&7${NAME} x${AMOUNT}'
    lore:
      - '&r '
      - '&r &7Нажмите лкм'
      - '&r &7чтобы купить ${NAME} в количестве ${AMOUNT}'
      - '&r '
    on_left_click:
      <<: *on_left_click_logic


animation:
  - frame:
      tick: 0 # на каком тике анимации следует применить этот фрейм, если не указать, то будет на один больше, чем предыдущий
      opcodes:
        - set: itemID 13 # устанавливает предмет в указанный слот
        - set: itemID 10-20 # устанавливает предмет в указанные слоты
        - set: AIR 10-20 # удаляет предметы в указанных слотах
        - remove: 10-20 # аналогично set: AIR 10-20
        - move: 13 14 # перемещает предмет из слота 13 в слот 14, в слот 13 устанавливается AIR
        - move: 10-15 20-25 # перемещает предметы из слотов 10-15 в слоты 20-25
        - move: 13++ # перемещает предмет из слота 13 в слот 14
        - move: 13-- # перемещает предмет из слота 13 в слот 12
        - swap: 10 11 # меняет местами предметы в слотах 10 и 11
        - swap: 10-15 20-25 # меняет местами предметы в слотах 10-15 и 20-25
        - copy: 10 11 # копирует предмет из слота 10 в слот 11
        - copy: 10-15 20-25 # копирует предметы из слотов 10-15 в слоты 20-25
        - goto: 13 # переходит к указанному тику, позволяет зациклить анимацию
        - sound: ENTITY_EXPERIENCE_ORB_PICKUP # воспроизводит звук для игрока
        - commands: # выполняет команды
            - '[MESSAGE] msg'



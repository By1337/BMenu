## Терминология
# Иерархия открытых меню
# При открытии одного меню из другого создаётся цепочка, называемая иерархией меню
# Иерархия существует до тех пор, пока последнее открытое меню остаётся открытым
# Меню не знает, какое меню находится выше по иерархии, но знает, какое было до него
# Пример:
# Есть меню A, B, C
# Пользователь открывает меню A
# Иерархия: A
# Из меню A пользователь открывает меню B
# Иерархия: A -> B
# Затем из меню B пользователь открывает меню C
# Иерархия: A -> B -> C
# В этом примере образовалась цепочка из трёх меню
# Меню B знает, что до него было меню A, но не знает, что после него меню C
# Если пользователь воспользуется командой [BACK], он вернётся в предыдущее меню, а текущее меню закроется
# Иерархия: A -> B


# Должны импортироваться все настройки указанных файлов, включая их extends
# Циклические зависимости не должны влиять на работу системы и считаются допустимыми
## Терминология
# указанные здесь меню это родительские меню
# текущее меню это наследник
extends:
  - ./file.yml # путь относительно текущей папки
  - ../file.yml # путь относительно папки на уровень выше
  - /file.yml  # путь относительно корневой папки с меню


# Объединяет файлы в один.
# Используйте это для импорта указателей.
# Объединение файлов происходит до чтения yaml, если вы объедините две менюшки то меню точно поломается,
# Для объединения менюшек используйте extends.
# Повторю этот параметр просто склеивает вда файла в один.
# УКАЗЫВАТЕ ФАЙЛЫ ТОЛЬКО В ТАКОМ ФОРМАТЕ include: []
# Также запрещено добавлять комментарии в блок include
# Всегда оборачивайте значения в кавычки.
include: [
  "./file.yml",
  "../file.yml",
  "/file.yml",
]

# здесь вы можете объявлять наборы команд
# после вы можете их выполнять используя команду
# [RUN] <имя набора>
# Или выполнять рандомно
# [RUN_RAND]
commands-list:
  example-1:
    weight: 1.0 # Необязательный параметр. Это вес этого набора он будет использоваться если вызвать случайные команды через [RUN_RAND]
    commands:
      - '[MESSAGE] &7Это команда из example-1'
  example-2:
    weight: 1.0
    commands:
      - '[MESSAGE] &7Это команда из example-1'

# Если namespace не указан, должно использоваться имя плагина, который загрузил это меню
# При использовании команд [OPEN] или аналогичных без указания конкретного namespace,
# menu loader должен сначала искать меню в своём окружении
# В случае неоднозначных вызовов должна быть выведена ошибка
# Один menu loader не может получить доступ к другому, если это явно не указано в реализации
# id может быть не указан, в этом случае menu loader не сможет найти это меню. Это может быть полезно при использовании зависимостей в extends
## Терминология
# меню без id называется безымянным
id: <namespace>:<id>
# Если namespace не указан, должно использоваться имя плагина, который загрузил это меню
# Все конфликты и неоднозначные указания реализаций должны быть выявлены на этапе загрузки menu loader
# Один menu loader не может получить доступ к реализациям другого, если это явно не указано в реализации
# Исключение составляют реализации по умолчанию, предоставляемые API
# provider может быть не указан, тогда это меню нельзя будет открыть
provider: <namespace>:<id>
type: CHEST
size: 27
title: '&7Menu title'

# Указывает из каких меню может быть открыто это меню
# Этот параметр наследуется из родительских меню
# Все наследники указанного здесь меню также имеют право открывать это меню
only-open-from:
  - <namespace>:<id>

# глобальные переменные меню
# могут быть использованы в любом месте в этом меню
# Все родительские меню также могут использовать эти переменные.
# Все наследники этого меню могут использовать эти переменные
# Этот параметр наследуется
# синтаксис использования ${PARAM_1}
# могут быть изменены командой [SET_PARAM]
# Эти параметры не статичны и уникальны для каждого открытого меню, а также они существуют пока это меню открыто или находится в иерархии открытых меню
args:
  PARAM_1: 'value'
  PARAM_2: 'value'
  PARAM_3: 'value'

# блок с дефолтными значениями
# он может назваться как угодно
# этот блок не наследуется
# здесь он приведён в качестве примера как можно использовать указатели и переменные которые можно объявить в предмете
defaults:
  on_left_click_logic: &on_left_click_logic
    requirements:
      type: math
      expression: '%balance% >= ${PRICE}'
    deny_commands:
      - '[MESSAGE] &cУ Вас не достаточно баланса!'
    commands:
      - '[CONSOLE] eco take %player_name% ${PRICE}'
      - '[CONSOLE] give %player_name% ${MATERIAL} ${AMOUNT}'
      - '[MESSAGE] &aВы успешно купили ${NAME} в количестве ${AMOUNT}'

items:
  # наследники могут использовать объявленные здесь предметы в анимациях,
  # Например если в этом меню и в родительском меню будут предметы с именем item-1 то это меню будет использовать свой item-1, а родительское свой item-1.
  itemID:
    material: <material> # или basehead-<value> или плейсхолдер
    display_name: "Имя предмета"
    amount: 1 # или плейсхолдер
    lore: [ ] # описание
    item_flags: [ ] # все флаги https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemFlag.html
    potion_effects:
      - "speed;20;0" # <PotionEffectType>;<duration>;<amplifier>
    color: '#aabbcc' # для зелий и кожиной брони
    enchantments:
      - protection;1 # enchantmentid;level
    unbreakable: true
    model_data: 0
    damage: 10
    priority: 0
    # слоты могут быть не указаны
    # если указать слоты то этот предмет установится при инициализации меню
    slot: 10
    slots:
      - '10'
      - '11'
      - '12-20'
    # аналог переменных меню, но только эти переменные видны только этому предмету
    # Также эти переменные константные.
    # Использовать аналогично ${PARAM_1}
    args:
      PARAM_1: 'value'
      PARAM_2: 'value'
      PARAM_3: 'value'
    view_requirement: # алиас view_req
      # если в type перед проверкой поставить ! то проверка будет работать на оборот
      # например type: '!has permission' такая проверка сработает если игрок не имеет пермишена
      requirements: # алиас req
        check: # если условие окажется ложным, то проверка остальных условий прервётся
          type: math
          expression: '100 + 100 == 10 * (5 * 4)'
        check-1:
          type: string equals
          input: 'str'
          output: 'str'
        check-2:
          type: string equals ignorecase
          input: 'str'
          output: 'STR'
        check-3:
          type: string contains
          input: 'str_str_str'
          output: 'str'
        check-4:
          type: regex matches
          regex: '^(str)\d+'
          input: 'str88ing'
        check-5:
          type: has permission
          permission: 'admin.use'
      # Здесь можно выполнить команды в зависимости от результатов условий
      deny_commands: [ ] # если хотя бы одно из условий окажется ложным
    on_left_click: # обработка клика
      requirements: # здесь можно указать условия
        check-1:
          type: string equals
          input: 'str'
          output: 'str'
      # Здесь можно указываются команды в зависимости от результатов проверки
      deny_commands: [ ]
      commands: [ ]

  example:
    args:
      MATERIAL: STONE
      PRICE: 10
      AMOUNT: 64
      NAME: 'камень'
    material: ${MATERIAL}
    amount: ${AMOUNT}
    display_name: '&7${NAME} x${AMOUNT}'
    lore:
      - '&r '
      - '&r &7Нажмите лкм'
      - '&r &7чтобы купить ${NAME} в количестве ${AMOUNT}'
      - '&r '
    on_left_click:
      <<: *on_left_click_logic


# Все виды кликов
# on_left_click
# on_right_click
# on_shift_left_click
# on_shift_right_click
# on_middle_click
# on_drop_click
# on_click - любой не назначенный клик
# on_number_key_0_click
# on_number_key_1_click
# on_number_key_2_click
# on_number_key_3_click
# on_number_key_4_click
# on_number_key_5_click
# on_number_key_6_click
# on_number_key_7_click
# on_number_key_8_click
# on_swap_offhand_click
# on_control_drop_click


# Вы можете использовать предметы, добавленные в родительские меню.
# Однако взаимодействовать с предметами, уже находящимися в меню, нельзя.
# Меню состоит из двух слоёв:
# - **Первый слой**: включает предметы, добавленные при открытии меню (те, что указаны в параметре `items` и привязаны к определённым слотам), а также предметы, установленные плагином.
# - **Второй слой**: это слой анимации, где находятся предметы, добавленные анимацией.
#
# Анимация может взаимодействовать только с элементами своего слоя, однако она может перекрывать предметы первого слоя.
animation:
  - tick: 0 # на каком тике анимации следует применить этот фрейм, если не указать, то будет на один больше, чем предыдущий
    opcodes:
      - set: itemID 13 # устанавливает предмет в указанный слот
      - set: itemID 10-20 # устанавливает предмет в указанные слоты
      - set: AIR 10-20 # удаляет предметы в указанных слотах
      - remove: 10-20 # аналогично set: AIR 10-20
      - move: 13 14 # перемещает предмет из слота 13 в слот 14, в слот 13 устанавливается AIR
      - move: 10-15 20-25 # перемещает предметы из слотов 10-15 в слоты 20-25
      - move: 13++ # перемещает предмет из слота 13 в слот 14
      - move: 13++ # перемещает предмет из слота 13 в слот 14
      - move: 13,17 15,20 # перемещает предметы из слотов 13 и 17 в слоты 15 и 20
      - swap: 10 11 # меняет местами предметы в слотах 10 и 11
      - swap: 10++ # меняет местами предметы в слотах 10 и 11
      - swap: 10-- # меняет местами предметы в слотах 10 и 9
      - swap: 10-15 20-25 # меняет местами предметы в слотах 10-15 и 20-25
      - copy: 10 11 # копирует предмет из слота 10 в слот 11
      - copy: 10++ # копирует предмет из слота 10 в слот 11
      - copy: 10-- # копирует предмет из слота 10 в слот 9
      - copy: 10-15 20-25 # копирует предметы из слотов 10-15 в слоты 20-25
      - goto: 13 # переходит к указанному тику, позволяет зациклить анимацию
      - sound: ENTITY_EXPERIENCE_ORB_PICKUP 1.0 1.0 # воспроизводит звук для игрока
      - commands: # выполняет команды
          - '[MESSAGE] msg'


# Все команды
# [CONSOLE] <cmd>
# [PLAYER] <cmd>
# [SOUND] <sound> <?volume> <?pitch>
# [CLOSE]
# здесь команды открытия меню
# В commands вы можете передать список команд которые необходимо выполнить в открывающейся менюшке
# Синтаксис [OPEN] menu ["[MESSAGE] сообщение из открытого меню", "[что-то] некст команда"]
# [BACK_OR_CLOSE] <?commands>
# [BACK_TO_OR_CLOSE] <id> <?commands>
# [BACK] <?commands>
# [OPEN] <id> <?commands>
#
# [REFRESH]
# [MESSAGE] <msg>
# [SET_PARAM] <param> <value>
# [IMPORT_PARAMS] <item>
# Команды ниже выполняют команды из блока commands-list
# [RUN] <имя набора>
# [RUN_RAND]
